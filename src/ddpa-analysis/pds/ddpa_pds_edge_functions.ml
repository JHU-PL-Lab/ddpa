open Batteries;;
open Jhupllib;;

open Ddpa_abstract_ast;;
open Ddpa_graph;;
open Ddpa_utils;;
open Pds_reachability_types_stack;;

let logger = Logger_utils.make_logger "Ddpa_pds_edge_functions";;
let lazy_logger = Logger_utils.make_lazy_logger "Ddpa_pds_edge_functions";;

module Make
    (Store_ops : Ddpa_abstract_stores.Ops.Sig)
    (Struct : (module type of Ddpa_pds_structure_types.Make(Store_ops))
     with module Store_ops = Store_ops)
    (T : (module type of Ddpa_pds_dynamic_pop_types.Make(Store_ops)(Struct))
     with module Store_ops = Store_ops
      and module Struct = Struct)
    (B : Pds_reachability_basis.Basis)
    (R : Pds_reachability_analysis.Analysis
     with type State.t = Struct.Pds_state.t
      and type Targeted_dynamic_pop_action.t = T.pds_targeted_dynamic_pop_action)
=
struct
  open Struct;;
  open T;;

  (**
     Creates a PDS edge function for a particular DDPA graph edge.  The
     resulting function produces transitions for PDS states, essentially serving
     as the first step toward implementing each DDPA rule.  The remaining steps
     are addressed by the dynamic pop handler, which performs the closure of the
     dynamic pops generated by this function.
  *)
  let create_edge_function
      (eobm : End_of_block_map.t) (edge : ddpa_edge) (state : R.State.t) =
    (* Unpack the edge *)
    let Ddpa_edge(acl1, acl0) = edge in
    (* Generate PDS edge functions for this DDPA edge *)
    Logger_utils.lazy_bracket_log (lazy_logger `trace)
      (fun () -> Printf.sprintf "DDPA %s edge function at state %s"
          (show_ddpa_edge edge) (Pds_state.show state))
      (fun edges ->
         let string_of_output (actions,target) =
           String_utils.string_of_tuple
             (String_utils.string_of_list R.show_stack_action)
             Pds_state.show
             (actions,target)
         in
         Printf.sprintf "Generates edges: %s"
           (String_utils.string_of_list string_of_output @@
            List.of_enum @@ Enum.clone edges)) @@
    fun () ->
    let zero = Enum.empty in
    let%orzero Program_point_state acl0' = state in
    (* TODO: There should be a way to associate each edge function with
             its corresponding acl0 rather than using this guard. *)
    [%guard (compare_annotated_clause acl0 acl0' == 0) ];
    let open Option.Monad in
    let zero () = None in
    (* TODO: remove these warning suppressions *)
    ignore eobm;
    ignore @@ zero ();
    (* TODO: It'd be nice if we had a terser way to represent stack
             processing operations (those that simply reorder the stack
             without transitioning to a different node). *)
    let targeted_dynamic_pops = Enum.filter_map identity @@ List.enum
        [
          (* ********** Store Processing ********** *)
          (* Discovered Store *)
          begin
            return (Discovered_store_2_of_2, Program_point_state acl0)
          end
          ;
          (* Intermediate Store *)
          begin
            return (Intermediate_store, Program_point_state acl0)
          end
          ;
          (* Store Suffix *)
          begin
            return (Store_suffix_1_of_2, Program_point_state acl0)
          end
          ;
          (* Store Parallel Join *)
          begin
            return (Store_parallel_join_1_of_3, Program_point_state acl0)
          end
          ;
          (* Store Serial Join *)
          begin
            return (Store_serial_join_1_of_3, Program_point_state acl0)
          end
          ;
          (* ********** Variable Search ********** *)
          (* Value Discovery *)
          begin
            let%orzero
              Unannotated_clause(Abs_clause(x,Abs_value_body v)) = acl1
            in
            return (Value_discovery(x,v), Program_point_state acl1)
          end
          ;
          (* Value Alias *)
          begin
            let%orzero
              Unannotated_clause(Abs_clause(x,Abs_var_body x')) = acl1
            in
            return (Value_alias(x,x'), Program_point_state acl1)
          end
          ;
          (* Stateless Clause Skip *)
          begin
            let%orzero Unannotated_clause(Abs_clause(x',_)) = acl1 in
            return (Stateless_clause_skip_1_of_2 x', Program_point_state acl1)
          end
          ;
          (* Block Marker Skip *)
          (* [[ this rule is handled in the nop states below ]] *)
          (* ********** Navigation ********** *)
          (* Jump *)
          (* [[ this rule is handled by untargeted dynamic pops ]] *)
          (* Capture *)
          begin
            return (Capture_1_of_3, Program_point_state acl1)
          end
        ]
    in
    let nop_states =
      match acl1 with
      | Start_clause _ | End_clause _ ->
        (* Block Marker Skip *)
        Enum.singleton @@ Program_point_state acl1
      | _ -> Enum.empty ()
    in
    Enum.append
      (targeted_dynamic_pops
       |> Enum.map
         (fun (action,state) -> ([Pop_dynamic_targeted(action)], state)))
      (nop_states
       |> Enum.map
         (fun state -> ([], state)))
  ;;

  let create_untargeted_dynamic_pop_action_function
      (edge : ddpa_edge) (state : R.State.t) =
    let Ddpa_edge(_, acl0) = edge in
    let zero = Enum.empty in
    let%orzero Program_point_state acl0' = state in
    (* TODO: There should be a way to associate each action function with
             its corresponding acl0 rather than using this guard. *)
    [%guard (compare_annotated_clause acl0 acl0' == 0)];
    let open Option.Monad in
    let untargeted_dynamic_pops = Enum.filter_map identity @@ List.enum
        [
          (* Store Processing: Discovered Store *)
          begin
            return @@ Discovered_store_1_of_2
          end
          ;
          (* Navigation: Jump. *)
          begin
            return @@ Do_jump
          end
        ]
    in
    untargeted_dynamic_pops
  ;;

end;;
